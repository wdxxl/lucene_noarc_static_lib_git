//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: jar:file:wdxxl_lucene_350.jar!org/apache/lucene/store/MMapDirectory.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/File.h"
#include "java/io/IOException.h"
#include "java/io/RandomAccessFile.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/reflect/Method.h"
#include "java/nio/Buffer.h"
#include "java/nio/BufferUnderflowException.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/MappedByteBuffer.h"
#include "java/nio/channels/FileChannel.h"
#include "java/security/AccessController.h"
#include "java/security/PrivilegedActionException.h"
#include "java/security/PrivilegedExceptionAction.h"
#include "org/apache/lucene/store/AlreadyClosedException.h"
#include "org/apache/lucene/store/FSDirectory.h"
#include "org/apache/lucene/store/IndexInput.h"
#include "org/apache/lucene/store/LockFactory.h"
#include "org/apache/lucene/store/MMapDirectory.h"
#include "org/apache/lucene/util/Constants.h"

@interface OrgApacheLuceneStoreMMapDirectory () {
 @public
  jboolean useUnmapHack_;
  jint chunkSizePower_;
}

@end

__attribute__((unused)) static void OrgApacheLuceneStoreMMapDirectory_cleanMappingWithJavaNioByteBuffer_(OrgApacheLuceneStoreMMapDirectory *self, JavaNioByteBuffer *buffer);

__attribute__((unused)) static void OrgApacheLuceneStoreMMapDirectory_setMaxChunkSizeWithInt_(OrgApacheLuceneStoreMMapDirectory *self, jint maxChunkSize);

@interface OrgApacheLuceneStoreMMapDirectory_1 : NSObject < JavaSecurityPrivilegedExceptionAction > {
 @public
  JavaNioByteBuffer *val$buffer_;
}

- (instancetype)initWithJavaNioByteBuffer:(JavaNioByteBuffer *)capture$0;

- (id)run;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneStoreMMapDirectory_1)

__attribute__((unused)) static void OrgApacheLuceneStoreMMapDirectory_1_initWithJavaNioByteBuffer_(OrgApacheLuceneStoreMMapDirectory_1 *self, JavaNioByteBuffer *capture$0);

__attribute__((unused)) static OrgApacheLuceneStoreMMapDirectory_1 *new_OrgApacheLuceneStoreMMapDirectory_1_initWithJavaNioByteBuffer_(JavaNioByteBuffer *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static OrgApacheLuceneStoreMMapDirectory_1 *create_OrgApacheLuceneStoreMMapDirectory_1_initWithJavaNioByteBuffer_(JavaNioByteBuffer *capture$0);

@interface OrgApacheLuceneStoreMMapDirectory_MMapIndexInput : OrgApacheLuceneStoreIndexInput {
 @public
  OrgApacheLuceneStoreMMapDirectory *this$0_;
  IOSObjectArray *buffers_;
  jlong length_;
  jlong chunkSizeMask_;
  jlong chunkSize_;
  jint chunkSizePower_;
  jint curBufIndex_;
  JavaNioByteBuffer *curBuf_;
  jboolean isClone_;
}

- (instancetype)initWithOrgApacheLuceneStoreMMapDirectory:(OrgApacheLuceneStoreMMapDirectory *)outer$
                                             withNSString:(NSString *)resourceDescription
                               withJavaIoRandomAccessFile:(JavaIoRandomAccessFile *)raf
                                                  withInt:(jint)chunkSizePower;

- (jbyte)readByte;

- (void)readBytesWithByteArray:(IOSByteArray *)b
                       withInt:(jint)offset
                       withInt:(jint)len;

- (jint)readInt;

- (jlong)readLong;

- (jlong)getFilePointer;

- (void)seekWithLong:(jlong)pos;

- (jlong)length;

- (id)java_clone;

- (void)close;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneStoreMMapDirectory_MMapIndexInput)

J2OBJC_FIELD_SETTER(OrgApacheLuceneStoreMMapDirectory_MMapIndexInput, buffers_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneStoreMMapDirectory_MMapIndexInput, curBuf_, JavaNioByteBuffer *)

__attribute__((unused)) static void OrgApacheLuceneStoreMMapDirectory_MMapIndexInput_initWithOrgApacheLuceneStoreMMapDirectory_withNSString_withJavaIoRandomAccessFile_withInt_(OrgApacheLuceneStoreMMapDirectory_MMapIndexInput *self, OrgApacheLuceneStoreMMapDirectory *outer$, NSString *resourceDescription, JavaIoRandomAccessFile *raf, jint chunkSizePower);

__attribute__((unused)) static OrgApacheLuceneStoreMMapDirectory_MMapIndexInput *new_OrgApacheLuceneStoreMMapDirectory_MMapIndexInput_initWithOrgApacheLuceneStoreMMapDirectory_withNSString_withJavaIoRandomAccessFile_withInt_(OrgApacheLuceneStoreMMapDirectory *outer$, NSString *resourceDescription, JavaIoRandomAccessFile *raf, jint chunkSizePower) NS_RETURNS_RETAINED;

__attribute__((unused)) static OrgApacheLuceneStoreMMapDirectory_MMapIndexInput *create_OrgApacheLuceneStoreMMapDirectory_MMapIndexInput_initWithOrgApacheLuceneStoreMMapDirectory_withNSString_withJavaIoRandomAccessFile_withInt_(OrgApacheLuceneStoreMMapDirectory *outer$, NSString *resourceDescription, JavaIoRandomAccessFile *raf, jint chunkSizePower);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneStoreMMapDirectory_MMapIndexInput)

J2OBJC_INITIALIZED_DEFN(OrgApacheLuceneStoreMMapDirectory)

jint OrgApacheLuceneStoreMMapDirectory_DEFAULT_MAX_BUFF;
jboolean OrgApacheLuceneStoreMMapDirectory_UNMAP_SUPPORTED;

@implementation OrgApacheLuceneStoreMMapDirectory

- (instancetype)initWithJavaIoFile:(JavaIoFile *)path
withOrgApacheLuceneStoreLockFactory:(OrgApacheLuceneStoreLockFactory *)lockFactory {
  OrgApacheLuceneStoreMMapDirectory_initWithJavaIoFile_withOrgApacheLuceneStoreLockFactory_(self, path, lockFactory);
  return self;
}

- (instancetype)initWithJavaIoFile:(JavaIoFile *)path {
  OrgApacheLuceneStoreMMapDirectory_initWithJavaIoFile_(self, path);
  return self;
}

- (void)setUseUnmapWithBoolean:(jboolean)useUnmapHack {
  if (useUnmapHack && !OrgApacheLuceneStoreMMapDirectory_UNMAP_SUPPORTED) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Unmap hack not supported on this platform!");
  self->useUnmapHack_ = useUnmapHack;
}

- (jboolean)getUseUnmap {
  return useUnmapHack_;
}

- (void)cleanMappingWithJavaNioByteBuffer:(JavaNioByteBuffer *)buffer {
  OrgApacheLuceneStoreMMapDirectory_cleanMappingWithJavaNioByteBuffer_(self, buffer);
}

- (void)setMaxChunkSizeWithInt:(jint)maxChunkSize {
  OrgApacheLuceneStoreMMapDirectory_setMaxChunkSizeWithInt_(self, maxChunkSize);
}

- (jint)getMaxChunkSize {
  return JreLShift32(1, chunkSizePower_);
}

- (OrgApacheLuceneStoreIndexInput *)openInputWithNSString:(NSString *)name
                                                  withInt:(jint)bufferSize {
  [self ensureOpen];
  JavaIoFile *f = create_JavaIoFile_initWithJavaIoFile_withNSString_([self getDirectory], name);
  JavaIoRandomAccessFile *raf = create_JavaIoRandomAccessFile_initWithJavaIoFile_withNSString_(f, @"r");
  @try {
    return create_OrgApacheLuceneStoreMMapDirectory_MMapIndexInput_initWithOrgApacheLuceneStoreMMapDirectory_withNSString_withJavaIoRandomAccessFile_withInt_(self, JreStrcat("$@$", @"MMapIndexInput(path=\"", f, @"\")"), raf, chunkSizePower_);
  }
  @finally {
    [raf close];
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, 1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, 1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x10, 5, 6, 1, -1, -1, -1 },
    { NULL, "V", 0x11, 7, 8, -1, -1, -1, -1 },
    { NULL, "I", 0x11, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOrgApacheLuceneStoreIndexInput;", 0x1, 9, 10, 1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaIoFile:withOrgApacheLuceneStoreLockFactory:);
  methods[1].selector = @selector(initWithJavaIoFile:);
  methods[2].selector = @selector(setUseUnmapWithBoolean:);
  methods[3].selector = @selector(getUseUnmap);
  methods[4].selector = @selector(cleanMappingWithJavaNioByteBuffer:);
  methods[5].selector = @selector(setMaxChunkSizeWithInt:);
  methods[6].selector = @selector(getMaxChunkSize);
  methods[7].selector = @selector(openInputWithNSString:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "useUnmapHack_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "DEFAULT_MAX_BUFF", "I", .constantValue.asLong = 0, 0x19, -1, 11, -1, -1 },
    { "chunkSizePower_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "UNMAP_SUPPORTED", "Z", .constantValue.asLong = 0, 0x19, -1, 12, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoFile;LOrgApacheLuceneStoreLockFactory;", "LJavaIoIOException;", "LJavaIoFile;", "setUseUnmap", "Z", "cleanMapping", "LJavaNioByteBuffer;", "setMaxChunkSize", "I", "openInput", "LNSString;I", &OrgApacheLuceneStoreMMapDirectory_DEFAULT_MAX_BUFF, &OrgApacheLuceneStoreMMapDirectory_UNMAP_SUPPORTED, "LOrgApacheLuceneStoreMMapDirectory_MMapIndexInput;" };
  static const J2ObjcClassInfo _OrgApacheLuceneStoreMMapDirectory = { "MMapDirectory", "org.apache.lucene.store", ptrTable, methods, fields, 7, 0x1, 8, 4, -1, 13, -1, -1, -1 };
  return &_OrgApacheLuceneStoreMMapDirectory;
}

+ (void)initialize {
  if (self == [OrgApacheLuceneStoreMMapDirectory class]) {
    OrgApacheLuceneStoreMMapDirectory_DEFAULT_MAX_BUFF = JreLoadStatic(OrgApacheLuceneUtilConstants, JRE_IS_64BIT) ? (JreLShift32(1, 30)) : (JreLShift32(1, 28));
    {
      jboolean v;
      @try {
        IOSClass_forName_(@"sun.misc.Cleaner");
        [((IOSClass *) nil_chk(IOSClass_forName_(@"java.nio.DirectByteBuffer"))) getMethod:@"cleaner" parameterTypes:[IOSObjectArray arrayWithLength:0 type:IOSClass_class_()]];
        v = true;
      }
      @catch (JavaLangException *e) {
        v = false;
      }
      OrgApacheLuceneStoreMMapDirectory_UNMAP_SUPPORTED = v;
    }
    J2OBJC_SET_INITIALIZED(OrgApacheLuceneStoreMMapDirectory)
  }
}

@end

void OrgApacheLuceneStoreMMapDirectory_initWithJavaIoFile_withOrgApacheLuceneStoreLockFactory_(OrgApacheLuceneStoreMMapDirectory *self, JavaIoFile *path, OrgApacheLuceneStoreLockFactory *lockFactory) {
  OrgApacheLuceneStoreFSDirectory_initWithJavaIoFile_withOrgApacheLuceneStoreLockFactory_(self, path, lockFactory);
  self->useUnmapHack_ = OrgApacheLuceneStoreMMapDirectory_UNMAP_SUPPORTED;
  OrgApacheLuceneStoreMMapDirectory_setMaxChunkSizeWithInt_(self, OrgApacheLuceneStoreMMapDirectory_DEFAULT_MAX_BUFF);
}

OrgApacheLuceneStoreMMapDirectory *new_OrgApacheLuceneStoreMMapDirectory_initWithJavaIoFile_withOrgApacheLuceneStoreLockFactory_(JavaIoFile *path, OrgApacheLuceneStoreLockFactory *lockFactory) {
  J2OBJC_NEW_IMPL(OrgApacheLuceneStoreMMapDirectory, initWithJavaIoFile_withOrgApacheLuceneStoreLockFactory_, path, lockFactory)
}

OrgApacheLuceneStoreMMapDirectory *create_OrgApacheLuceneStoreMMapDirectory_initWithJavaIoFile_withOrgApacheLuceneStoreLockFactory_(JavaIoFile *path, OrgApacheLuceneStoreLockFactory *lockFactory) {
  J2OBJC_CREATE_IMPL(OrgApacheLuceneStoreMMapDirectory, initWithJavaIoFile_withOrgApacheLuceneStoreLockFactory_, path, lockFactory)
}

void OrgApacheLuceneStoreMMapDirectory_initWithJavaIoFile_(OrgApacheLuceneStoreMMapDirectory *self, JavaIoFile *path) {
  OrgApacheLuceneStoreFSDirectory_initWithJavaIoFile_withOrgApacheLuceneStoreLockFactory_(self, path, nil);
  self->useUnmapHack_ = OrgApacheLuceneStoreMMapDirectory_UNMAP_SUPPORTED;
  OrgApacheLuceneStoreMMapDirectory_setMaxChunkSizeWithInt_(self, OrgApacheLuceneStoreMMapDirectory_DEFAULT_MAX_BUFF);
}

OrgApacheLuceneStoreMMapDirectory *new_OrgApacheLuceneStoreMMapDirectory_initWithJavaIoFile_(JavaIoFile *path) {
  J2OBJC_NEW_IMPL(OrgApacheLuceneStoreMMapDirectory, initWithJavaIoFile_, path)
}

OrgApacheLuceneStoreMMapDirectory *create_OrgApacheLuceneStoreMMapDirectory_initWithJavaIoFile_(JavaIoFile *path) {
  J2OBJC_CREATE_IMPL(OrgApacheLuceneStoreMMapDirectory, initWithJavaIoFile_, path)
}

void OrgApacheLuceneStoreMMapDirectory_cleanMappingWithJavaNioByteBuffer_(OrgApacheLuceneStoreMMapDirectory *self, JavaNioByteBuffer *buffer) {
  if (self->useUnmapHack_) {
    @try {
      JavaSecurityAccessController_doPrivilegedWithJavaSecurityPrivilegedExceptionAction_(create_OrgApacheLuceneStoreMMapDirectory_1_initWithJavaNioByteBuffer_(buffer));
    }
    @catch (JavaSecurityPrivilegedActionException *e) {
      JavaIoIOException *ioe = create_JavaIoIOException_initWithNSString_(@"unable to unmap the mapped buffer");
      [ioe initCauseWithNSException:[e getCause]];
      @throw ioe;
    }
  }
}

void OrgApacheLuceneStoreMMapDirectory_setMaxChunkSizeWithInt_(OrgApacheLuceneStoreMMapDirectory *self, jint maxChunkSize) {
  if (maxChunkSize <= 0) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Maximum chunk size for mmap must be >0");
  self->chunkSizePower_ = 31 - JavaLangInteger_numberOfLeadingZerosWithInt_(maxChunkSize);
  JreAssert((self->chunkSizePower_ >= 0 && self->chunkSizePower_ <= 30), (@"org/apache/lucene/store/MMapDirectory.java:197 condition failed: assert this.chunkSizePower >= 0 && this.chunkSizePower <= 30;"));
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheLuceneStoreMMapDirectory)

@implementation OrgApacheLuceneStoreMMapDirectory_1

- (instancetype)initWithJavaNioByteBuffer:(JavaNioByteBuffer *)capture$0 {
  OrgApacheLuceneStoreMMapDirectory_1_initWithJavaNioByteBuffer_(self, capture$0);
  return self;
}

- (id)run {
  JavaLangReflectMethod *getCleanerMethod = [[((JavaNioByteBuffer *) nil_chk(val$buffer_)) java_getClass] getMethod:@"cleaner" parameterTypes:[IOSObjectArray arrayWithLength:0 type:IOSClass_class_()]];
  [((JavaLangReflectMethod *) nil_chk(getCleanerMethod)) setAccessibleWithBoolean:true];
  id cleaner = [getCleanerMethod invokeWithId:val$buffer_ withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSObject_class_()]];
  if (cleaner != nil) {
    [((JavaLangReflectMethod *) nil_chk([[cleaner java_getClass] getMethod:@"clean" parameterTypes:[IOSObjectArray arrayWithLength:0 type:IOSClass_class_()]])) invokeWithId:cleaner withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSObject_class_()]];
  }
  return nil;
}

- (void)dealloc {
  RELEASE_(val$buffer_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, -1, -1, 0, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaNioByteBuffer:);
  methods[1].selector = @selector(run);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$buffer_", "LJavaNioByteBuffer;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangException;", "LOrgApacheLuceneStoreMMapDirectory;", "cleanMappingWithJavaNioByteBuffer:", "Ljava/lang/Object;Ljava/security/PrivilegedExceptionAction<Ljava/lang/Object;>;" };
  static const J2ObjcClassInfo _OrgApacheLuceneStoreMMapDirectory_1 = { "", "org.apache.lucene.store", ptrTable, methods, fields, 7, 0x8018, 2, 1, 1, -1, 2, 3, -1 };
  return &_OrgApacheLuceneStoreMMapDirectory_1;
}

@end

void OrgApacheLuceneStoreMMapDirectory_1_initWithJavaNioByteBuffer_(OrgApacheLuceneStoreMMapDirectory_1 *self, JavaNioByteBuffer *capture$0) {
  JreStrongAssign(&self->val$buffer_, capture$0);
  NSObject_init(self);
}

OrgApacheLuceneStoreMMapDirectory_1 *new_OrgApacheLuceneStoreMMapDirectory_1_initWithJavaNioByteBuffer_(JavaNioByteBuffer *capture$0) {
  J2OBJC_NEW_IMPL(OrgApacheLuceneStoreMMapDirectory_1, initWithJavaNioByteBuffer_, capture$0)
}

OrgApacheLuceneStoreMMapDirectory_1 *create_OrgApacheLuceneStoreMMapDirectory_1_initWithJavaNioByteBuffer_(JavaNioByteBuffer *capture$0) {
  J2OBJC_CREATE_IMPL(OrgApacheLuceneStoreMMapDirectory_1, initWithJavaNioByteBuffer_, capture$0)
}

@implementation OrgApacheLuceneStoreMMapDirectory_MMapIndexInput

- (instancetype)initWithOrgApacheLuceneStoreMMapDirectory:(OrgApacheLuceneStoreMMapDirectory *)outer$
                                             withNSString:(NSString *)resourceDescription
                               withJavaIoRandomAccessFile:(JavaIoRandomAccessFile *)raf
                                                  withInt:(jint)chunkSizePower {
  OrgApacheLuceneStoreMMapDirectory_MMapIndexInput_initWithOrgApacheLuceneStoreMMapDirectory_withNSString_withJavaIoRandomAccessFile_withInt_(self, outer$, resourceDescription, raf, chunkSizePower);
  return self;
}

- (jbyte)readByte {
  @try {
    return [((JavaNioByteBuffer *) nil_chk(curBuf_)) get];
  }
  @catch (JavaNioBufferUnderflowException *e) {
    do {
      curBufIndex_++;
      if (curBufIndex_ >= ((IOSObjectArray *) nil_chk(buffers_))->size_) {
        @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$@", @"read past EOF: ", self));
      }
      JreStrongAssign(&curBuf_, IOSObjectArray_Get(buffers_, curBufIndex_));
      [((JavaNioByteBuffer *) nil_chk(curBuf_)) positionWithInt:0];
    }
    while (![((JavaNioByteBuffer *) nil_chk(curBuf_)) hasRemaining]);
    return [((JavaNioByteBuffer *) nil_chk(curBuf_)) get];
  }
}

- (void)readBytesWithByteArray:(IOSByteArray *)b
                       withInt:(jint)offset
                       withInt:(jint)len {
  @try {
    [((JavaNioByteBuffer *) nil_chk(curBuf_)) getWithByteArray:b withInt:offset withInt:len];
  }
  @catch (JavaNioBufferUnderflowException *e) {
    jint curAvail = [((JavaNioByteBuffer *) nil_chk(curBuf_)) remaining];
    while (len > curAvail) {
      [((JavaNioByteBuffer *) nil_chk(curBuf_)) getWithByteArray:b withInt:offset withInt:curAvail];
      len -= curAvail;
      offset += curAvail;
      curBufIndex_++;
      if (curBufIndex_ >= ((IOSObjectArray *) nil_chk(buffers_))->size_) {
        @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$@", @"read past EOF: ", self));
      }
      JreStrongAssign(&curBuf_, IOSObjectArray_Get(buffers_, curBufIndex_));
      [((JavaNioByteBuffer *) nil_chk(curBuf_)) positionWithInt:0];
      curAvail = [((JavaNioByteBuffer *) nil_chk(curBuf_)) remaining];
    }
    [((JavaNioByteBuffer *) nil_chk(curBuf_)) getWithByteArray:b withInt:offset withInt:len];
  }
}

- (jint)readInt {
  @try {
    return [((JavaNioByteBuffer *) nil_chk(curBuf_)) getInt];
  }
  @catch (JavaNioBufferUnderflowException *e) {
    return [super readInt];
  }
}

- (jlong)readLong {
  @try {
    return [((JavaNioByteBuffer *) nil_chk(curBuf_)) getLong];
  }
  @catch (JavaNioBufferUnderflowException *e) {
    return [super readLong];
  }
}

- (jlong)getFilePointer {
  return (JreLShift64(((jlong) curBufIndex_), chunkSizePower_)) + [((JavaNioByteBuffer *) nil_chk(curBuf_)) position];
}

- (void)seekWithLong:(jlong)pos {
  jint bi = (jint) (JreRShift64(pos, chunkSizePower_));
  @try {
    JavaNioByteBuffer *b = IOSObjectArray_Get(nil_chk(buffers_), bi);
    [((JavaNioByteBuffer *) nil_chk(b)) positionWithInt:(jint) (pos & chunkSizeMask_)];
    self->curBufIndex_ = bi;
    JreStrongAssign(&self->curBuf_, b);
  }
  @catch (JavaLangArrayIndexOutOfBoundsException *aioobe) {
    if (pos < 0LL) {
      @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@", @"Seeking to negative position: ", self));
    }
    @throw create_JavaIoIOException_initWithNSString_(@"seek past EOF");
  }
  @catch (JavaLangIllegalArgumentException *iae) {
    if (pos < 0LL) {
      @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@", @"Seeking to negative position: ", self));
    }
    @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$@", @"seek past EOF: ", self));
  }
}

- (jlong)length {
  return length_;
}

- (id)java_clone {
  if (buffers_ == nil) {
    @throw create_OrgApacheLuceneStoreAlreadyClosedException_initWithNSString_(JreStrcat("$@", @"MMapIndexInput already closed: ", self));
  }
  OrgApacheLuceneStoreMMapDirectory_MMapIndexInput *clone = (OrgApacheLuceneStoreMMapDirectory_MMapIndexInput *) cast_chk([super java_clone], [OrgApacheLuceneStoreMMapDirectory_MMapIndexInput class]);
  ((OrgApacheLuceneStoreMMapDirectory_MMapIndexInput *) nil_chk(clone))->isClone_ = true;
  JreStrongAssignAndConsume(&clone->buffers_, [IOSObjectArray newArrayWithLength:((IOSObjectArray *) nil_chk(buffers_))->size_ type:JavaNioByteBuffer_class_()]);
  for (jint bufNr = 0; bufNr < ((IOSObjectArray *) nil_chk(buffers_))->size_; bufNr++) {
    IOSObjectArray_Set(clone->buffers_, bufNr, [((JavaNioByteBuffer *) nil_chk(IOSObjectArray_Get(buffers_, bufNr))) duplicate]);
  }
  @try {
    [clone seekWithLong:[self getFilePointer]];
  }
  @catch (JavaIoIOException *ioe) {
    @throw create_JavaLangRuntimeException_initWithNSString_withNSException_(JreStrcat("$@", @"Should never happen: ", self), ioe);
  }
  return clone;
}

- (void)close {
  @try {
    if (isClone_ || buffers_ == nil) return;
    for (jint bufNr = 0; bufNr < buffers_->size_; bufNr++) {
      @try {
        OrgApacheLuceneStoreMMapDirectory_cleanMappingWithJavaNioByteBuffer_(this$0_, IOSObjectArray_Get(buffers_, bufNr));
      }
      @finally {
        IOSObjectArray_Set(nil_chk(buffers_), bufNr, nil);
      }
    }
  }
  @finally {
    JreStrongAssign(&buffers_, nil);
  }
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(buffers_);
  RELEASE_(curBuf_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, 1, -1, -1, -1 },
    { NULL, "B", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, 1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, 1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, 6, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgApacheLuceneStoreMMapDirectory:withNSString:withJavaIoRandomAccessFile:withInt:);
  methods[1].selector = @selector(readByte);
  methods[2].selector = @selector(readBytesWithByteArray:withInt:withInt:);
  methods[3].selector = @selector(readInt);
  methods[4].selector = @selector(readLong);
  methods[5].selector = @selector(getFilePointer);
  methods[6].selector = @selector(seekWithLong:);
  methods[7].selector = @selector(length);
  methods[8].selector = @selector(java_clone);
  methods[9].selector = @selector(close);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LOrgApacheLuceneStoreMMapDirectory;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "buffers_", "[LJavaNioByteBuffer;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "length_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "chunkSizeMask_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "chunkSize_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "chunkSizePower_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "curBufIndex_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "curBuf_", "LJavaNioByteBuffer;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "isClone_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNSString;LJavaIoRandomAccessFile;I", "LJavaIoIOException;", "readBytes", "[BII", "seek", "J", "clone", "LOrgApacheLuceneStoreMMapDirectory;" };
  static const J2ObjcClassInfo _OrgApacheLuceneStoreMMapDirectory_MMapIndexInput = { "MMapIndexInput", "org.apache.lucene.store", ptrTable, methods, fields, 7, 0x12, 10, 9, 7, -1, -1, -1, -1 };
  return &_OrgApacheLuceneStoreMMapDirectory_MMapIndexInput;
}

@end

void OrgApacheLuceneStoreMMapDirectory_MMapIndexInput_initWithOrgApacheLuceneStoreMMapDirectory_withNSString_withJavaIoRandomAccessFile_withInt_(OrgApacheLuceneStoreMMapDirectory_MMapIndexInput *self, OrgApacheLuceneStoreMMapDirectory *outer$, NSString *resourceDescription, JavaIoRandomAccessFile *raf, jint chunkSizePower) {
  JreStrongAssign(&self->this$0_, outer$);
  OrgApacheLuceneStoreIndexInput_initWithNSString_(self, resourceDescription);
  self->isClone_ = false;
  self->length_ = [((JavaIoRandomAccessFile *) nil_chk(raf)) length];
  self->chunkSizePower_ = chunkSizePower;
  self->chunkSize_ = JreLShift64(1LL, chunkSizePower);
  self->chunkSizeMask_ = self->chunkSize_ - 1LL;
  if (chunkSizePower < 0 || chunkSizePower > 30) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Invalid chunkSizePower used for ByteBuffer size: ", chunkSizePower));
  if ((JreURShift64(self->length_, chunkSizePower)) >= JavaLangInteger_MAX_VALUE) @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"RandomAccessFile too big for chunk size: ", [raf description]));
  jint nrBuffers = (jint) (JreURShift64(self->length_, chunkSizePower)) + 1;
  JreStrongAssignAndConsume(&self->buffers_, [IOSObjectArray newArrayWithLength:nrBuffers type:JavaNioByteBuffer_class_()]);
  jlong bufferStart = 0LL;
  JavaNioChannelsFileChannel *rafc = [raf getChannel];
  for (jint bufNr = 0; bufNr < nrBuffers; bufNr++) {
    jint bufSize = (jint) ((self->length_ > (bufferStart + self->chunkSize_)) ? self->chunkSize_ : (self->length_ - bufferStart));
    IOSObjectArray_Set(nil_chk(self->buffers_), bufNr, [((JavaNioChannelsFileChannel *) nil_chk(rafc)) mapWithJavaNioChannelsFileChannel_MapMode:JreLoadStatic(JavaNioChannelsFileChannel_MapMode, READ_ONLY) withLong:bufferStart withLong:bufSize]);
    bufferStart += bufSize;
  }
  [self seekWithLong:0LL];
}

OrgApacheLuceneStoreMMapDirectory_MMapIndexInput *new_OrgApacheLuceneStoreMMapDirectory_MMapIndexInput_initWithOrgApacheLuceneStoreMMapDirectory_withNSString_withJavaIoRandomAccessFile_withInt_(OrgApacheLuceneStoreMMapDirectory *outer$, NSString *resourceDescription, JavaIoRandomAccessFile *raf, jint chunkSizePower) {
  J2OBJC_NEW_IMPL(OrgApacheLuceneStoreMMapDirectory_MMapIndexInput, initWithOrgApacheLuceneStoreMMapDirectory_withNSString_withJavaIoRandomAccessFile_withInt_, outer$, resourceDescription, raf, chunkSizePower)
}

OrgApacheLuceneStoreMMapDirectory_MMapIndexInput *create_OrgApacheLuceneStoreMMapDirectory_MMapIndexInput_initWithOrgApacheLuceneStoreMMapDirectory_withNSString_withJavaIoRandomAccessFile_withInt_(OrgApacheLuceneStoreMMapDirectory *outer$, NSString *resourceDescription, JavaIoRandomAccessFile *raf, jint chunkSizePower) {
  J2OBJC_CREATE_IMPL(OrgApacheLuceneStoreMMapDirectory_MMapIndexInput, initWithOrgApacheLuceneStoreMMapDirectory_withNSString_withJavaIoRandomAccessFile_withInt_, outer$, resourceDescription, raf, chunkSizePower)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheLuceneStoreMMapDirectory_MMapIndexInput)
