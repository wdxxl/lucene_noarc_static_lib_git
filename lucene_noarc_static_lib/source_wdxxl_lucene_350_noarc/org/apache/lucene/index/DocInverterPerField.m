//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: jar:file:wdxxl_lucene_350.jar!org/apache/lucene/index/DocInverterPerField.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/io/PrintStream.h"
#include "java/io/Reader.h"
#include "java/lang/IllegalArgumentException.h"
#include "org/apache/lucene/analysis/Analyzer.h"
#include "org/apache/lucene/analysis/TokenStream.h"
#include "org/apache/lucene/analysis/tokenattributes/OffsetAttribute.h"
#include "org/apache/lucene/analysis/tokenattributes/PositionIncrementAttribute.h"
#include "org/apache/lucene/document/Document.h"
#include "org/apache/lucene/document/Fieldable.h"
#include "org/apache/lucene/index/DocFieldConsumerPerField.h"
#include "org/apache/lucene/index/DocInverterPerField.h"
#include "org/apache/lucene/index/DocInverterPerThread.h"
#include "org/apache/lucene/index/DocumentsWriter.h"
#include "org/apache/lucene/index/FieldInfo.h"
#include "org/apache/lucene/index/FieldInvertState.h"
#include "org/apache/lucene/index/InvertedDocConsumerPerField.h"
#include "org/apache/lucene/index/InvertedDocConsumerPerThread.h"
#include "org/apache/lucene/index/InvertedDocEndConsumerPerField.h"
#include "org/apache/lucene/index/InvertedDocEndConsumerPerThread.h"
#include "org/apache/lucene/index/ReusableStringReader.h"
#include "org/apache/lucene/util/AttributeSource.h"

@interface OrgApacheLuceneIndexDocInverterPerField () {
 @public
  OrgApacheLuceneIndexDocInverterPerThread *perThread_;
  OrgApacheLuceneIndexFieldInfo *fieldInfo_;
}

@end

J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexDocInverterPerField, perThread_, OrgApacheLuceneIndexDocInverterPerThread *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexDocInverterPerField, fieldInfo_, OrgApacheLuceneIndexFieldInfo *)

@implementation OrgApacheLuceneIndexDocInverterPerField

- (instancetype)initWithOrgApacheLuceneIndexDocInverterPerThread:(OrgApacheLuceneIndexDocInverterPerThread *)perThread
                               withOrgApacheLuceneIndexFieldInfo:(OrgApacheLuceneIndexFieldInfo *)fieldInfo {
  OrgApacheLuceneIndexDocInverterPerField_initWithOrgApacheLuceneIndexDocInverterPerThread_withOrgApacheLuceneIndexFieldInfo_(self, perThread, fieldInfo);
  return self;
}

- (void)abort {
  @try {
    [((OrgApacheLuceneIndexInvertedDocConsumerPerField *) nil_chk(consumer_)) abort];
  }
  @finally {
    [((OrgApacheLuceneIndexInvertedDocEndConsumerPerField *) nil_chk(endConsumer_)) abort];
  }
}

- (void)processFieldsWithOrgApacheLuceneDocumentFieldableArray:(IOSObjectArray *)fields
                                                       withInt:(jint)count {
  [((OrgApacheLuceneIndexFieldInvertState *) nil_chk(fieldState_)) resetWithFloat:[((OrgApacheLuceneDocumentDocument *) nil_chk(((OrgApacheLuceneIndexDocumentsWriter_DocState *) nil_chk(docState_))->doc_)) getBoost]];
  jint maxFieldLength = docState_->maxFieldLength_;
  jboolean doInvert = [((OrgApacheLuceneIndexInvertedDocConsumerPerField *) nil_chk(consumer_)) startWithOrgApacheLuceneDocumentFieldableArray:fields withInt:count];
  for (jint i = 0; i < count; i++) {
    id<OrgApacheLuceneDocumentFieldable> field = IOSObjectArray_Get(nil_chk(fields), i);
    if ([((id<OrgApacheLuceneDocumentFieldable>) nil_chk(field)) isIndexed] && doInvert) {
      if (i > 0) fieldState_->position_ += docState_->analyzer_ == nil ? 0 : [docState_->analyzer_ getPositionIncrementGapWithNSString:((OrgApacheLuceneIndexFieldInfo *) nil_chk(fieldInfo_))->name_];
      if (![field isTokenized]) {
        NSString *stringValue = [field stringValue];
        jint valueLength = [((NSString *) nil_chk(stringValue)) java_length];
        [((OrgApacheLuceneIndexDocInverterPerThread_SingleTokenAttributeSource *) nil_chk(((OrgApacheLuceneIndexDocInverterPerThread *) nil_chk(perThread_))->singleToken_)) reinitWithNSString:stringValue withInt:0 withInt:valueLength];
        JreStrongAssign(&fieldState_->attributeSource_, perThread_->singleToken_);
        [consumer_ startWithOrgApacheLuceneDocumentFieldable:field];
        jboolean success = false;
        @try {
          [consumer_ add];
          success = true;
        }
        @finally {
          if (!success) [((OrgApacheLuceneIndexDocumentsWriter *) nil_chk(docState_->docWriter_)) setAborting];
        }
        fieldState_->offset_ += valueLength;
        fieldState_->length_++;
        fieldState_->position_++;
      }
      else {
        OrgApacheLuceneAnalysisTokenStream *stream;
        OrgApacheLuceneAnalysisTokenStream *streamValue = [field tokenStreamValue];
        if (streamValue != nil) stream = streamValue;
        else {
          JavaIoReader *reader;
          JavaIoReader *readerValue = [field readerValue];
          if (readerValue != nil) reader = readerValue;
          else {
            NSString *stringValue = [field stringValue];
            if (stringValue == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"field must have either TokenStream, String or Reader value");
            [((OrgApacheLuceneIndexReusableStringReader *) nil_chk(((OrgApacheLuceneIndexDocInverterPerThread *) nil_chk(perThread_))->stringReader_)) init__WithNSString:stringValue];
            reader = perThread_->stringReader_;
          }
          stream = [((OrgApacheLuceneAnalysisAnalyzer *) nil_chk(docState_->analyzer_)) reusableTokenStreamWithNSString:((OrgApacheLuceneIndexFieldInfo *) nil_chk(fieldInfo_))->name_ withJavaIoReader:reader];
        }
        [((OrgApacheLuceneAnalysisTokenStream *) nil_chk(stream)) reset];
        jint startLength = fieldState_->length_;
        @try {
          jboolean hasMoreTokens = [stream incrementToken];
          JreStrongAssign(&fieldState_->attributeSource_, stream);
          id<OrgApacheLuceneAnalysisTokenattributesOffsetAttribute> offsetAttribute = ((id<OrgApacheLuceneAnalysisTokenattributesOffsetAttribute>) [fieldState_->attributeSource_ addAttributeWithIOSClass:OrgApacheLuceneAnalysisTokenattributesOffsetAttribute_class_()]);
          id<OrgApacheLuceneAnalysisTokenattributesPositionIncrementAttribute> posIncrAttribute = ((id<OrgApacheLuceneAnalysisTokenattributesPositionIncrementAttribute>) [((OrgApacheLuceneUtilAttributeSource *) nil_chk(fieldState_->attributeSource_)) addAttributeWithIOSClass:OrgApacheLuceneAnalysisTokenattributesPositionIncrementAttribute_class_()]);
          [consumer_ startWithOrgApacheLuceneDocumentFieldable:field];
          for (; ; ) {
            if (!hasMoreTokens) break;
            jint posIncr = [((id<OrgApacheLuceneAnalysisTokenattributesPositionIncrementAttribute>) nil_chk(posIncrAttribute)) getPositionIncrement];
            fieldState_->position_ += posIncr;
            if (fieldState_->position_ > 0) {
              fieldState_->position_--;
            }
            if (posIncr == 0) fieldState_->numOverlap_++;
            jboolean success = false;
            @try {
              [consumer_ add];
              success = true;
            }
            @finally {
              if (!success) [((OrgApacheLuceneIndexDocumentsWriter *) nil_chk(docState_->docWriter_)) setAborting];
            }
            fieldState_->position_++;
            if (++fieldState_->length_ >= maxFieldLength) {
              if (docState_->infoStream_ != nil) [docState_->infoStream_ printlnWithNSString:JreStrcat("$I$$$", @"maxFieldLength ", maxFieldLength, @" reached for field ", ((OrgApacheLuceneIndexFieldInfo *) nil_chk(fieldInfo_))->name_, @", ignoring following tokens")];
              break;
            }
            hasMoreTokens = [stream incrementToken];
          }
          [stream end];
          fieldState_->offset_ += [((id<OrgApacheLuceneAnalysisTokenattributesOffsetAttribute>) nil_chk(offsetAttribute)) endOffset];
        }
        @finally {
          [stream close];
        }
      }
      fieldState_->offset_ += docState_->analyzer_ == nil ? 0 : [docState_->analyzer_ getOffsetGapWithOrgApacheLuceneDocumentFieldable:field];
      JreTimesAssignFloatF(&fieldState_->boost_, [field getBoost]);
    }
    IOSObjectArray_Set(fields, i, nil);
  }
  [consumer_ finish];
  [((OrgApacheLuceneIndexInvertedDocEndConsumerPerField *) nil_chk(endConsumer_)) finish];
}

- (void)dealloc {
  RELEASE_(perThread_);
  RELEASE_(fieldInfo_);
  RELEASE_(consumer_);
  RELEASE_(endConsumer_);
  RELEASE_(docState_);
  RELEASE_(fieldState_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, 3, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgApacheLuceneIndexDocInverterPerThread:withOrgApacheLuceneIndexFieldInfo:);
  methods[1].selector = @selector(abort);
  methods[2].selector = @selector(processFieldsWithOrgApacheLuceneDocumentFieldableArray:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "perThread_", "LOrgApacheLuceneIndexDocInverterPerThread;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "fieldInfo_", "LOrgApacheLuceneIndexFieldInfo;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "consumer_", "LOrgApacheLuceneIndexInvertedDocConsumerPerField;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "endConsumer_", "LOrgApacheLuceneIndexInvertedDocEndConsumerPerField;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "docState_", "LOrgApacheLuceneIndexDocumentsWriter_DocState;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "fieldState_", "LOrgApacheLuceneIndexFieldInvertState;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgApacheLuceneIndexDocInverterPerThread;LOrgApacheLuceneIndexFieldInfo;", "processFields", "[LOrgApacheLuceneDocumentFieldable;I", "LJavaIoIOException;" };
  static const J2ObjcClassInfo _OrgApacheLuceneIndexDocInverterPerField = { "DocInverterPerField", "org.apache.lucene.index", ptrTable, methods, fields, 7, 0x10, 3, 6, -1, -1, -1, -1, -1 };
  return &_OrgApacheLuceneIndexDocInverterPerField;
}

@end

void OrgApacheLuceneIndexDocInverterPerField_initWithOrgApacheLuceneIndexDocInverterPerThread_withOrgApacheLuceneIndexFieldInfo_(OrgApacheLuceneIndexDocInverterPerField *self, OrgApacheLuceneIndexDocInverterPerThread *perThread, OrgApacheLuceneIndexFieldInfo *fieldInfo) {
  OrgApacheLuceneIndexDocFieldConsumerPerField_init(self);
  JreStrongAssign(&self->perThread_, perThread);
  JreStrongAssign(&self->fieldInfo_, fieldInfo);
  JreStrongAssign(&self->docState_, ((OrgApacheLuceneIndexDocInverterPerThread *) nil_chk(perThread))->docState_);
  JreStrongAssign(&self->fieldState_, perThread->fieldState_);
  JreStrongAssign(&self->consumer_, [((OrgApacheLuceneIndexInvertedDocConsumerPerThread *) nil_chk(perThread->consumer_)) addFieldWithOrgApacheLuceneIndexDocInverterPerField:self withOrgApacheLuceneIndexFieldInfo:fieldInfo]);
  JreStrongAssign(&self->endConsumer_, [((OrgApacheLuceneIndexInvertedDocEndConsumerPerThread *) nil_chk(perThread->endConsumer_)) addFieldWithOrgApacheLuceneIndexDocInverterPerField:self withOrgApacheLuceneIndexFieldInfo:fieldInfo]);
}

OrgApacheLuceneIndexDocInverterPerField *new_OrgApacheLuceneIndexDocInverterPerField_initWithOrgApacheLuceneIndexDocInverterPerThread_withOrgApacheLuceneIndexFieldInfo_(OrgApacheLuceneIndexDocInverterPerThread *perThread, OrgApacheLuceneIndexFieldInfo *fieldInfo) {
  J2OBJC_NEW_IMPL(OrgApacheLuceneIndexDocInverterPerField, initWithOrgApacheLuceneIndexDocInverterPerThread_withOrgApacheLuceneIndexFieldInfo_, perThread, fieldInfo)
}

OrgApacheLuceneIndexDocInverterPerField *create_OrgApacheLuceneIndexDocInverterPerField_initWithOrgApacheLuceneIndexDocInverterPerThread_withOrgApacheLuceneIndexFieldInfo_(OrgApacheLuceneIndexDocInverterPerThread *perThread, OrgApacheLuceneIndexFieldInfo *fieldInfo) {
  J2OBJC_CREATE_IMPL(OrgApacheLuceneIndexDocInverterPerField, initWithOrgApacheLuceneIndexDocInverterPerThread_withOrgApacheLuceneIndexFieldInfo_, perThread, fieldInfo)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheLuceneIndexDocInverterPerField)
